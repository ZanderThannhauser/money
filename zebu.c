#include "zebu.h"

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <errno.h>

const unsigned zebu_shifts[144][18] = {
	[1][2] = 2,
	[1][3] = 3,
	[1][4] = 4,
	[1][5] = 5,
	[1][6] = 6,
	[2][7] = 11,
	[4][5] = 12,
	[5][2] = 14,
	[5][3] = 15,
	[5][4] = 16,
	[5][5] = 17,
	[5][6] = 18,
	[5][10] = 19,
	[5][11] = 20,
	[6][5] = 12,
	[8][8] = 28,
	[8][9] = 29,
	[9][2] = 2,
	[9][3] = 3,
	[9][4] = 4,
	[9][5] = 5,
	[9][6] = 6,
	[11][2] = 32,
	[11][3] = 33,
	[11][4] = 34,
	[11][5] = 35,
	[11][6] = 36,
	[11][10] = 37,
	[11][11] = 38,
	[12][2] = 14,
	[12][3] = 15,
	[12][4] = 16,
	[12][5] = 17,
	[12][6] = 18,
	[12][10] = 19,
	[12][11] = 20,
	[16][5] = 45,
	[17][2] = 14,
	[17][3] = 15,
	[17][4] = 16,
	[17][5] = 17,
	[17][6] = 18,
	[17][10] = 19,
	[17][11] = 20,
	[18][5] = 45,
	[19][2] = 14,
	[19][3] = 15,
	[19][4] = 16,
	[19][5] = 17,
	[19][6] = 18,
	[19][10] = 19,
	[19][11] = 20,
	[20][2] = 14,
	[20][3] = 15,
	[20][4] = 16,
	[20][5] = 17,
	[20][6] = 18,
	[20][10] = 19,
	[20][11] = 20,
	[22][10] = 53,
	[22][11] = 54,
	[23][13] = 55,
	[24][8] = 57,
	[24][14] = 56,
	[28][2] = 58,
	[28][3] = 3,
	[28][4] = 4,
	[28][5] = 5,
	[28][6] = 6,
	[29][2] = 32,
	[29][3] = 33,
	[29][4] = 34,
	[29][5] = 35,
	[29][6] = 36,
	[29][10] = 37,
	[29][11] = 38,
	[31][2] = 2,
	[31][3] = 3,
	[31][4] = 4,
	[31][5] = 5,
	[31][6] = 6,
	[34][5] = 63,
	[35][2] = 14,
	[35][3] = 15,
	[35][4] = 16,
	[35][5] = 17,
	[35][6] = 18,
	[35][10] = 19,
	[35][11] = 20,
	[36][5] = 63,
	[37][2] = 32,
	[37][3] = 33,
	[37][4] = 34,
	[37][5] = 35,
	[37][6] = 36,
	[37][10] = 37,
	[37][11] = 38,
	[38][2] = 32,
	[38][3] = 33,
	[38][4] = 34,
	[38][5] = 35,
	[38][6] = 36,
	[38][10] = 37,
	[38][11] = 38,
	[39][10] = 71,
	[39][11] = 72,
	[40][15] = 73,
	[41][8] = 75,
	[41][14] = 74,
	[45][2] = 14,
	[45][3] = 15,
	[45][4] = 16,
	[45][5] = 17,
	[45][6] = 18,
	[45][10] = 19,
	[45][11] = 20,
	[48][13] = 77,
	[53][2] = 14,
	[53][3] = 15,
	[53][4] = 16,
	[53][5] = 17,
	[53][6] = 18,
	[53][10] = 19,
	[53][11] = 20,
	[54][2] = 14,
	[54][3] = 15,
	[54][4] = 16,
	[54][5] = 17,
	[54][6] = 18,
	[54][10] = 19,
	[54][11] = 20,
	[56][2] = 14,
	[56][3] = 15,
	[56][4] = 16,
	[56][5] = 17,
	[56][6] = 18,
	[56][10] = 19,
	[56][11] = 20,
	[57][2] = 14,
	[57][3] = 15,
	[57][4] = 16,
	[57][5] = 17,
	[57][6] = 18,
	[57][10] = 19,
	[57][11] = 20,
	[59][8] = 84,
	[59][9] = 85,
	[61][15] = 86,
	[63][2] = 14,
	[63][3] = 15,
	[63][4] = 16,
	[63][5] = 17,
	[63][6] = 18,
	[63][10] = 19,
	[63][11] = 20,
	[66][13] = 88,
	[71][2] = 32,
	[71][3] = 33,
	[71][4] = 34,
	[71][5] = 35,
	[71][6] = 36,
	[71][10] = 37,
	[71][11] = 38,
	[72][2] = 32,
	[72][3] = 33,
	[72][4] = 34,
	[72][5] = 35,
	[72][6] = 36,
	[72][10] = 37,
	[72][11] = 38,
	[74][2] = 32,
	[74][3] = 33,
	[74][4] = 34,
	[74][5] = 35,
	[74][6] = 36,
	[74][10] = 37,
	[74][11] = 38,
	[75][2] = 32,
	[75][3] = 33,
	[75][4] = 34,
	[75][5] = 35,
	[75][6] = 36,
	[75][10] = 37,
	[75][11] = 38,
	[79][8] = 57,
	[79][14] = 56,
	[84][2] = 95,
	[84][3] = 96,
	[84][4] = 97,
	[84][5] = 98,
	[84][6] = 99,
	[85][2] = 32,
	[85][3] = 33,
	[85][4] = 34,
	[85][5] = 35,
	[85][6] = 36,
	[85][10] = 37,
	[85][11] = 38,
	[90][8] = 75,
	[90][14] = 74,
	[97][5] = 102,
	[98][2] = 14,
	[98][3] = 15,
	[98][4] = 16,
	[98][5] = 17,
	[98][6] = 18,
	[98][10] = 19,
	[98][11] = 20,
	[99][5] = 102,
	[100][9] = 108,
	[100][16] = 107,
	[102][2] = 14,
	[102][3] = 15,
	[102][4] = 16,
	[102][5] = 17,
	[102][6] = 18,
	[102][10] = 19,
	[102][11] = 20,
	[105][13] = 110,
	[107][2] = 111,
	[107][3] = 112,
	[107][4] = 113,
	[107][5] = 114,
	[107][6] = 115,
	[108][2] = 32,
	[108][3] = 33,
	[108][4] = 34,
	[108][5] = 35,
	[108][6] = 36,
	[108][10] = 37,
	[108][11] = 38,
	[113][5] = 118,
	[114][2] = 14,
	[114][3] = 15,
	[114][4] = 16,
	[114][5] = 17,
	[114][6] = 18,
	[114][10] = 19,
	[114][11] = 20,
	[115][5] = 118,
	[116][9] = 124,
	[116][17] = 123,
	[118][2] = 14,
	[118][3] = 15,
	[118][4] = 16,
	[118][5] = 17,
	[118][6] = 18,
	[118][10] = 19,
	[118][11] = 20,
	[121][13] = 126,
	[123][2] = 111,
	[123][3] = 112,
	[123][4] = 113,
	[123][5] = 114,
	[123][6] = 115,
	[124][2] = 32,
	[124][3] = 33,
	[124][4] = 34,
	[124][5] = 35,
	[124][6] = 36,
	[124][10] = 37,
	[124][11] = 38,
	[127][9] = 130,
	[127][17] = 129,
	[129][2] = 131,
	[129][3] = 132,
	[129][4] = 133,
	[129][5] = 134,
	[129][6] = 135,
	[130][2] = 32,
	[130][3] = 33,
	[130][4] = 34,
	[130][5] = 35,
	[130][6] = 36,
	[130][10] = 37,
	[130][11] = 38,
	[133][5] = 138,
	[134][2] = 14,
	[134][3] = 15,
	[134][4] = 16,
	[134][5] = 17,
	[134][6] = 18,
	[134][10] = 19,
	[134][11] = 20,
	[135][5] = 138,
	[136][9] = 143,
	[138][2] = 14,
	[138][3] = 15,
	[138][4] = 16,
	[138][5] = 17,
	[138][6] = 18,
	[138][10] = 19,
	[138][11] = 20,
	[141][13] = 145,
	[143][2] = 32,
	[143][3] = 33,
	[143][4] = 34,
	[143][5] = 35,
	[143][6] = 36,
	[143][10] = 37,
	[143][11] = 38,
};


const unsigned zebu_reduces[147][18] = {
	[2][8] = 1,
	[2][9] = 1,
	[3][8] = 2,
	[3][9] = 2,
	[7][2] = 3,
	[7][3] = 3,
	[7][4] = 3,
	[7][5] = 3,
	[7][6] = 3,
	[7][12] = 3,
	[9][12] = 4,
	[10][2] = 5,
	[10][3] = 5,
	[10][4] = 5,
	[10][5] = 5,
	[10][6] = 5,
	[10][12] = 5,
	[13][8] = 6,
	[13][9] = 6,
	[14][8] = 1,
	[14][10] = 1,
	[14][11] = 1,
	[14][13] = 1,
	[14][14] = 1,
	[15][8] = 2,
	[15][10] = 2,
	[15][11] = 2,
	[15][13] = 2,
	[15][14] = 2,
	[21][8] = 7,
	[21][9] = 7,
	[22][13] = 8,
	[24][10] = 9,
	[24][11] = 9,
	[24][13] = 9,
	[25][8] = 10,
	[25][10] = 10,
	[25][11] = 10,
	[25][13] = 10,
	[25][14] = 10,
	[26][8] = 11,
	[26][10] = 11,
	[26][11] = 11,
	[26][13] = 11,
	[26][14] = 11,
	[27][8] = 12,
	[27][9] = 12,
	[30][12] = 13,
	[31][12] = 14,
	[32][8] = 1,
	[32][10] = 1,
	[32][11] = 1,
	[32][14] = 1,
	[32][15] = 1,
	[33][8] = 2,
	[33][10] = 2,
	[33][11] = 2,
	[33][14] = 2,
	[33][15] = 2,
	[39][15] = 8,
	[41][10] = 9,
	[41][11] = 9,
	[41][15] = 9,
	[42][8] = 10,
	[42][10] = 10,
	[42][11] = 10,
	[42][14] = 10,
	[42][15] = 10,
	[43][8] = 11,
	[43][10] = 11,
	[43][11] = 11,
	[43][14] = 11,
	[43][15] = 11,
	[44][8] = 15,
	[44][9] = 15,
	[46][8] = 6,
	[46][10] = 6,
	[46][11] = 6,
	[46][13] = 6,
	[46][14] = 6,
	[47][8] = 7,
	[47][10] = 7,
	[47][11] = 7,
	[47][13] = 7,
	[47][14] = 7,
	[49][8] = 12,
	[49][10] = 12,
	[49][11] = 12,
	[49][13] = 12,
	[49][14] = 12,
	[50][8] = 16,
	[50][10] = 16,
	[50][11] = 16,
	[50][13] = 16,
	[50][14] = 16,
	[51][8] = 17,
	[51][10] = 17,
	[51][11] = 17,
	[51][13] = 17,
	[51][14] = 17,
	[52][8] = 18,
	[52][10] = 18,
	[52][11] = 18,
	[52][13] = 18,
	[52][14] = 18,
	[55][8] = 19,
	[55][9] = 19,
	[58][8] = 1,
	[58][9] = 1,
	[60][2] = 20,
	[60][3] = 20,
	[60][4] = 20,
	[60][5] = 20,
	[60][6] = 20,
	[60][12] = 20,
	[62][12] = 21,
	[64][8] = 6,
	[64][10] = 6,
	[64][11] = 6,
	[64][14] = 6,
	[64][15] = 6,
	[65][8] = 7,
	[65][10] = 7,
	[65][11] = 7,
	[65][14] = 7,
	[65][15] = 7,
	[67][8] = 12,
	[67][10] = 12,
	[67][11] = 12,
	[67][14] = 12,
	[67][15] = 12,
	[68][8] = 16,
	[68][10] = 16,
	[68][11] = 16,
	[68][14] = 16,
	[68][15] = 16,
	[69][8] = 17,
	[69][10] = 17,
	[69][11] = 17,
	[69][14] = 17,
	[69][15] = 17,
	[70][8] = 18,
	[70][10] = 18,
	[70][11] = 18,
	[70][14] = 18,
	[70][15] = 18,
	[73][2] = 22,
	[73][3] = 22,
	[73][4] = 22,
	[73][5] = 22,
	[73][6] = 22,
	[73][12] = 22,
	[76][8] = 15,
	[76][10] = 15,
	[76][11] = 15,
	[76][13] = 15,
	[76][14] = 15,
	[77][8] = 19,
	[77][10] = 19,
	[77][11] = 19,
	[77][13] = 19,
	[77][14] = 19,
	[78][10] = 23,
	[78][11] = 23,
	[78][13] = 23,
	[79][10] = 24,
	[79][11] = 24,
	[79][13] = 24,
	[80][10] = 25,
	[80][11] = 25,
	[80][13] = 25,
	[81][8] = 26,
	[81][10] = 26,
	[81][11] = 26,
	[81][13] = 26,
	[81][14] = 26,
	[82][8] = 27,
	[82][10] = 27,
	[82][11] = 27,
	[82][13] = 27,
	[82][14] = 27,
	[83][8] = 28,
	[83][10] = 28,
	[83][11] = 28,
	[83][13] = 28,
	[83][14] = 28,
	[86][2] = 29,
	[86][3] = 29,
	[86][4] = 29,
	[86][5] = 29,
	[86][6] = 29,
	[86][12] = 29,
	[87][8] = 15,
	[87][10] = 15,
	[87][11] = 15,
	[87][14] = 15,
	[87][15] = 15,
	[88][8] = 19,
	[88][10] = 19,
	[88][11] = 19,
	[88][14] = 19,
	[88][15] = 19,
	[89][10] = 23,
	[89][11] = 23,
	[89][15] = 23,
	[90][10] = 24,
	[90][11] = 24,
	[90][15] = 24,
	[91][10] = 25,
	[91][11] = 25,
	[91][15] = 25,
	[92][8] = 26,
	[92][10] = 26,
	[92][11] = 26,
	[92][14] = 26,
	[92][15] = 26,
	[93][8] = 27,
	[93][10] = 27,
	[93][11] = 27,
	[93][14] = 27,
	[93][15] = 27,
	[94][8] = 28,
	[94][10] = 28,
	[94][11] = 28,
	[94][14] = 28,
	[94][15] = 28,
	[95][9] = 1,
	[95][16] = 1,
	[96][9] = 2,
	[96][16] = 2,
	[101][2] = 30,
	[101][3] = 30,
	[101][4] = 30,
	[101][5] = 30,
	[101][6] = 30,
	[101][12] = 30,
	[103][9] = 6,
	[103][16] = 6,
	[104][9] = 7,
	[104][16] = 7,
	[106][9] = 12,
	[106][16] = 12,
	[109][9] = 15,
	[109][16] = 15,
	[110][9] = 19,
	[110][16] = 19,
	[111][9] = 1,
	[111][17] = 1,
	[112][9] = 2,
	[112][17] = 2,
	[117][2] = 31,
	[117][3] = 31,
	[117][4] = 31,
	[117][5] = 31,
	[117][6] = 31,
	[117][12] = 31,
	[119][9] = 6,
	[119][17] = 6,
	[120][9] = 7,
	[120][17] = 7,
	[122][9] = 12,
	[122][17] = 12,
	[125][9] = 15,
	[125][17] = 15,
	[126][9] = 19,
	[126][17] = 19,
	[128][2] = 32,
	[128][3] = 32,
	[128][4] = 32,
	[128][5] = 32,
	[128][6] = 32,
	[128][12] = 32,
	[131][9] = 1,
	[132][9] = 2,
	[137][2] = 33,
	[137][3] = 33,
	[137][4] = 33,
	[137][5] = 33,
	[137][6] = 33,
	[137][12] = 33,
	[139][9] = 6,
	[140][9] = 7,
	[142][9] = 12,
	[144][9] = 15,
	[145][9] = 19,
	[146][2] = 34,
	[146][3] = 34,
	[146][4] = 34,
	[146][5] = 34,
	[146][6] = 34,
	[146][12] = 34,
};


const unsigned zebu_gotos[144][16] = {
	[1][1] = 7,
	[1][2] = 8,
	[1][3] = 9,
	[1][4] = 10,
	[4][5] = 13,
	[5][2] = 25,
	[5][6] = 21,
	[5][7] = 22,
	[5][8] = 23,
	[5][9] = 24,
	[5][10] = 26,
	[6][5] = 27,
	[9][1] = 7,
	[9][2] = 8,
	[9][3] = 31,
	[9][4] = 10,
	[9][11] = 30,
	[11][2] = 42,
	[11][7] = 39,
	[11][8] = 40,
	[11][9] = 41,
	[11][10] = 43,
	[12][2] = 25,
	[12][6] = 44,
	[12][7] = 22,
	[12][8] = 23,
	[12][9] = 24,
	[12][10] = 26,
	[16][5] = 46,
	[17][2] = 25,
	[17][6] = 47,
	[17][7] = 22,
	[17][8] = 48,
	[17][9] = 24,
	[17][10] = 26,
	[18][5] = 49,
	[19][2] = 25,
	[19][10] = 51,
	[19][12] = 50,
	[20][2] = 25,
	[20][10] = 51,
	[20][12] = 52,
	[28][2] = 59,
	[29][2] = 42,
	[29][7] = 39,
	[29][8] = 61,
	[29][9] = 41,
	[29][10] = 43,
	[29][13] = 60,
	[31][1] = 7,
	[31][2] = 8,
	[31][3] = 31,
	[31][4] = 10,
	[31][11] = 62,
	[34][5] = 64,
	[35][2] = 25,
	[35][6] = 65,
	[35][7] = 22,
	[35][8] = 66,
	[35][9] = 24,
	[35][10] = 26,
	[36][5] = 67,
	[37][2] = 42,
	[37][10] = 69,
	[37][12] = 68,
	[38][2] = 42,
	[38][10] = 69,
	[38][12] = 70,
	[45][2] = 25,
	[45][6] = 76,
	[45][7] = 22,
	[45][8] = 48,
	[45][9] = 24,
	[45][10] = 26,
	[53][2] = 25,
	[53][9] = 79,
	[53][10] = 26,
	[53][14] = 78,
	[54][2] = 25,
	[54][9] = 79,
	[54][10] = 26,
	[54][14] = 80,
	[56][2] = 25,
	[56][10] = 82,
	[56][15] = 81,
	[57][2] = 25,
	[57][10] = 82,
	[57][15] = 83,
	[63][2] = 25,
	[63][6] = 87,
	[63][7] = 22,
	[63][8] = 66,
	[63][9] = 24,
	[63][10] = 26,
	[71][2] = 42,
	[71][9] = 90,
	[71][10] = 43,
	[71][14] = 89,
	[72][2] = 42,
	[72][9] = 90,
	[72][10] = 43,
	[72][14] = 91,
	[74][2] = 42,
	[74][10] = 93,
	[74][15] = 92,
	[75][2] = 42,
	[75][10] = 93,
	[75][15] = 94,
	[84][2] = 100,
	[85][2] = 42,
	[85][7] = 39,
	[85][8] = 61,
	[85][9] = 41,
	[85][10] = 43,
	[85][13] = 101,
	[97][5] = 103,
	[98][2] = 25,
	[98][6] = 104,
	[98][7] = 22,
	[98][8] = 105,
	[98][9] = 24,
	[98][10] = 26,
	[99][5] = 106,
	[102][2] = 25,
	[102][6] = 109,
	[102][7] = 22,
	[102][8] = 105,
	[102][9] = 24,
	[102][10] = 26,
	[107][2] = 116,
	[108][2] = 42,
	[108][7] = 39,
	[108][8] = 61,
	[108][9] = 41,
	[108][10] = 43,
	[108][13] = 117,
	[113][5] = 119,
	[114][2] = 25,
	[114][6] = 120,
	[114][7] = 22,
	[114][8] = 121,
	[114][9] = 24,
	[114][10] = 26,
	[115][5] = 122,
	[118][2] = 25,
	[118][6] = 125,
	[118][7] = 22,
	[118][8] = 121,
	[118][9] = 24,
	[118][10] = 26,
	[123][2] = 127,
	[124][2] = 42,
	[124][7] = 39,
	[124][8] = 61,
	[124][9] = 41,
	[124][10] = 43,
	[124][13] = 128,
	[129][2] = 136,
	[130][2] = 42,
	[130][7] = 39,
	[130][8] = 61,
	[130][9] = 41,
	[130][10] = 43,
	[130][13] = 137,
	[133][5] = 139,
	[134][2] = 25,
	[134][6] = 140,
	[134][7] = 22,
	[134][8] = 141,
	[134][9] = 24,
	[134][10] = 26,
	[135][5] = 142,
	[138][2] = 25,
	[138][6] = 144,
	[138][7] = 22,
	[138][8] = 141,
	[138][9] = 24,
	[138][10] = 26,
	[143][2] = 42,
	[143][7] = 39,
	[143][8] = 61,
	[143][9] = 41,
	[143][10] = 43,
	[143][13] = 146,
};


const unsigned zebu_lexer[46][256] = {
	[1][9] = 17,
	[1][10] = 17,
	[1][32] = 17,
	[1][35] = 18,
	[1][40] = 19,
	[1][48] = 20,
	[1][49] = 20,
	[1][50] = 20,
	[1][51] = 20,
	[1][52] = 20,
	[1][53] = 20,
	[1][54] = 20,
	[1][55] = 20,
	[1][56] = 20,
	[1][57] = 20,
	[1][65] = 21,
	[1][66] = 21,
	[1][67] = 21,
	[1][68] = 21,
	[1][69] = 21,
	[1][70] = 21,
	[1][71] = 21,
	[1][72] = 21,
	[1][73] = 21,
	[1][74] = 21,
	[1][75] = 21,
	[1][76] = 21,
	[1][77] = 21,
	[1][78] = 21,
	[1][79] = 21,
	[1][80] = 21,
	[1][81] = 21,
	[1][82] = 21,
	[1][83] = 21,
	[1][84] = 21,
	[1][85] = 21,
	[1][86] = 21,
	[1][87] = 21,
	[1][88] = 21,
	[1][89] = 21,
	[1][90] = 21,
	[1][95] = 21,
	[1][97] = 21,
	[1][98] = 21,
	[1][99] = 22,
	[1][100] = 21,
	[1][101] = 21,
	[1][102] = 23,
	[1][103] = 21,
	[1][104] = 21,
	[1][105] = 21,
	[1][106] = 21,
	[1][107] = 21,
	[1][108] = 21,
	[1][109] = 21,
	[1][110] = 21,
	[1][111] = 21,
	[1][112] = 21,
	[1][113] = 21,
	[1][114] = 21,
	[1][115] = 21,
	[1][116] = 21,
	[1][117] = 21,
	[1][118] = 21,
	[1][119] = 21,
	[1][120] = 21,
	[1][121] = 21,
	[1][122] = 21,
	[2][9] = 17,
	[2][10] = 17,
	[2][32] = 17,
	[2][35] = 18,
	[2][47] = 24,
	[2][58] = 25,
	[2][61] = 26,
	[3][9] = 17,
	[3][10] = 17,
	[3][32] = 17,
	[3][35] = 18,
	[3][47] = 24,
	[3][58] = 25,
	[4][9] = 17,
	[4][10] = 17,
	[4][32] = 17,
	[4][35] = 18,
	[4][40] = 19,
	[5][9] = 17,
	[5][10] = 17,
	[5][32] = 17,
	[5][35] = 18,
	[5][40] = 19,
	[5][43] = 27,
	[5][45] = 28,
	[5][48] = 20,
	[5][49] = 20,
	[5][50] = 20,
	[5][51] = 20,
	[5][52] = 20,
	[5][53] = 20,
	[5][54] = 20,
	[5][55] = 20,
	[5][56] = 20,
	[5][57] = 20,
	[5][65] = 21,
	[5][66] = 21,
	[5][67] = 21,
	[5][68] = 21,
	[5][69] = 21,
	[5][70] = 21,
	[5][71] = 21,
	[5][72] = 21,
	[5][73] = 21,
	[5][74] = 21,
	[5][75] = 21,
	[5][76] = 21,
	[5][77] = 21,
	[5][78] = 21,
	[5][79] = 21,
	[5][80] = 21,
	[5][81] = 21,
	[5][82] = 21,
	[5][83] = 21,
	[5][84] = 21,
	[5][85] = 21,
	[5][86] = 21,
	[5][87] = 21,
	[5][88] = 21,
	[5][89] = 21,
	[5][90] = 21,
	[5][95] = 21,
	[5][97] = 21,
	[5][98] = 21,
	[5][99] = 22,
	[5][100] = 21,
	[5][101] = 21,
	[5][102] = 23,
	[5][103] = 21,
	[5][104] = 21,
	[5][105] = 21,
	[5][106] = 21,
	[5][107] = 21,
	[5][108] = 21,
	[5][109] = 21,
	[5][110] = 21,
	[5][111] = 21,
	[5][112] = 21,
	[5][113] = 21,
	[5][114] = 21,
	[5][115] = 21,
	[5][116] = 21,
	[5][117] = 21,
	[5][118] = 21,
	[5][119] = 21,
	[5][120] = 21,
	[5][121] = 21,
	[5][122] = 21,
	[6][9] = 17,
	[6][10] = 17,
	[6][32] = 17,
	[6][35] = 18,
	[6][40] = 19,
	[6][48] = 20,
	[6][49] = 20,
	[6][50] = 20,
	[6][51] = 20,
	[6][52] = 20,
	[6][53] = 20,
	[6][54] = 20,
	[6][55] = 20,
	[6][56] = 20,
	[6][57] = 20,
	[6][65] = 21,
	[6][66] = 21,
	[6][67] = 21,
	[6][68] = 21,
	[6][69] = 21,
	[6][70] = 21,
	[6][71] = 21,
	[6][72] = 21,
	[6][73] = 21,
	[6][74] = 21,
	[6][75] = 21,
	[6][76] = 21,
	[6][77] = 21,
	[6][78] = 21,
	[6][79] = 21,
	[6][80] = 21,
	[6][81] = 21,
	[6][82] = 21,
	[6][83] = 21,
	[6][84] = 21,
	[6][85] = 21,
	[6][86] = 21,
	[6][87] = 21,
	[6][88] = 21,
	[6][89] = 21,
	[6][90] = 21,
	[6][95] = 21,
	[6][97] = 21,
	[6][98] = 21,
	[6][99] = 22,
	[6][100] = 21,
	[6][101] = 21,
	[6][102] = 23,
	[6][103] = 21,
	[6][104] = 21,
	[6][105] = 21,
	[6][106] = 21,
	[6][107] = 21,
	[6][108] = 21,
	[6][109] = 21,
	[6][110] = 21,
	[6][111] = 21,
	[6][112] = 21,
	[6][113] = 21,
	[6][114] = 21,
	[6][115] = 21,
	[6][116] = 21,
	[6][117] = 21,
	[6][118] = 21,
	[6][119] = 21,
	[6][120] = 21,
	[6][121] = 21,
	[6][122] = 21,
	[7][9] = 17,
	[7][10] = 17,
	[7][32] = 17,
	[7][35] = 18,
	[7][41] = 30,
	[7][42] = 31,
	[7][43] = 27,
	[7][45] = 28,
	[7][47] = 24,
	[8][9] = 17,
	[8][10] = 17,
	[8][32] = 17,
	[8][35] = 18,
	[8][41] = 30,
	[8][43] = 27,
	[8][45] = 28,
	[9][9] = 17,
	[9][10] = 17,
	[9][32] = 17,
	[9][35] = 18,
	[9][41] = 30,
	[10][9] = 17,
	[10][10] = 17,
	[10][32] = 17,
	[10][35] = 18,
	[11][9] = 17,
	[11][10] = 17,
	[11][32] = 17,
	[11][35] = 18,
	[11][42] = 31,
	[11][43] = 27,
	[11][45] = 28,
	[11][47] = 24,
	[11][59] = 32,
	[12][9] = 17,
	[12][10] = 17,
	[12][32] = 17,
	[12][35] = 18,
	[12][43] = 27,
	[12][45] = 28,
	[12][59] = 32,
	[13][9] = 17,
	[13][10] = 17,
	[13][32] = 17,
	[13][35] = 18,
	[13][59] = 32,
	[14][9] = 17,
	[14][10] = 17,
	[14][32] = 17,
	[14][35] = 18,
	[14][58] = 25,
	[14][64] = 33,
	[15][9] = 17,
	[15][10] = 17,
	[15][32] = 17,
	[15][35] = 18,
	[15][58] = 34,
	[16][9] = 17,
	[16][10] = 17,
	[16][32] = 17,
	[16][35] = 18,
	[16][58] = 25,
	[17][9] = 17,
	[17][10] = 17,
	[17][32] = 17,
	[17][35] = 18,
	[18][0] = 18,
	[18][1] = 18,
	[18][2] = 18,
	[18][3] = 18,
	[18][4] = 18,
	[18][5] = 18,
	[18][6] = 18,
	[18][7] = 18,
	[18][8] = 18,
	[18][9] = 18,
	[18][10] = 17,
	[18][11] = 18,
	[18][12] = 18,
	[18][13] = 18,
	[18][14] = 18,
	[18][15] = 18,
	[18][16] = 18,
	[18][17] = 18,
	[18][18] = 18,
	[18][19] = 18,
	[18][20] = 18,
	[18][21] = 18,
	[18][22] = 18,
	[18][23] = 18,
	[18][24] = 18,
	[18][25] = 18,
	[18][26] = 18,
	[18][27] = 18,
	[18][28] = 18,
	[18][29] = 18,
	[18][30] = 18,
	[18][31] = 18,
	[18][32] = 18,
	[18][33] = 18,
	[18][34] = 18,
	[18][35] = 18,
	[18][36] = 18,
	[18][37] = 18,
	[18][38] = 18,
	[18][39] = 18,
	[18][40] = 18,
	[18][41] = 18,
	[18][42] = 18,
	[18][43] = 18,
	[18][44] = 18,
	[18][45] = 18,
	[18][46] = 18,
	[18][47] = 18,
	[18][48] = 18,
	[18][49] = 18,
	[18][50] = 18,
	[18][51] = 18,
	[18][52] = 18,
	[18][53] = 18,
	[18][54] = 18,
	[18][55] = 18,
	[18][56] = 18,
	[18][57] = 18,
	[18][58] = 18,
	[18][59] = 18,
	[18][60] = 18,
	[18][61] = 18,
	[18][62] = 18,
	[18][63] = 18,
	[18][64] = 18,
	[18][65] = 18,
	[18][66] = 18,
	[18][67] = 18,
	[18][68] = 18,
	[18][69] = 18,
	[18][70] = 18,
	[18][71] = 18,
	[18][72] = 18,
	[18][73] = 18,
	[18][74] = 18,
	[18][75] = 18,
	[18][76] = 18,
	[18][77] = 18,
	[18][78] = 18,
	[18][79] = 18,
	[18][80] = 18,
	[18][81] = 18,
	[18][82] = 18,
	[18][83] = 18,
	[18][84] = 18,
	[18][85] = 18,
	[18][86] = 18,
	[18][87] = 18,
	[18][88] = 18,
	[18][89] = 18,
	[18][90] = 18,
	[18][91] = 18,
	[18][92] = 18,
	[18][93] = 18,
	[18][94] = 18,
	[18][95] = 18,
	[18][96] = 18,
	[18][97] = 18,
	[18][98] = 18,
	[18][99] = 18,
	[18][100] = 18,
	[18][101] = 18,
	[18][102] = 18,
	[18][103] = 18,
	[18][104] = 18,
	[18][105] = 18,
	[18][106] = 18,
	[18][107] = 18,
	[18][108] = 18,
	[18][109] = 18,
	[18][110] = 18,
	[18][111] = 18,
	[18][112] = 18,
	[18][113] = 18,
	[18][114] = 18,
	[18][115] = 18,
	[18][116] = 18,
	[18][117] = 18,
	[18][118] = 18,
	[18][119] = 18,
	[18][120] = 18,
	[18][121] = 18,
	[18][122] = 18,
	[18][123] = 18,
	[18][124] = 18,
	[18][125] = 18,
	[18][126] = 18,
	[18][127] = 18,
	[18][128] = 18,
	[18][129] = 18,
	[18][130] = 18,
	[18][131] = 18,
	[18][132] = 18,
	[18][133] = 18,
	[18][134] = 18,
	[18][135] = 18,
	[18][136] = 18,
	[18][137] = 18,
	[18][138] = 18,
	[18][139] = 18,
	[18][140] = 18,
	[18][141] = 18,
	[18][142] = 18,
	[18][143] = 18,
	[18][144] = 18,
	[18][145] = 18,
	[18][146] = 18,
	[18][147] = 18,
	[18][148] = 18,
	[18][149] = 18,
	[18][150] = 18,
	[18][151] = 18,
	[18][152] = 18,
	[18][153] = 18,
	[18][154] = 18,
	[18][155] = 18,
	[18][156] = 18,
	[18][157] = 18,
	[18][158] = 18,
	[18][159] = 18,
	[18][160] = 18,
	[18][161] = 18,
	[18][162] = 18,
	[18][163] = 18,
	[18][164] = 18,
	[18][165] = 18,
	[18][166] = 18,
	[18][167] = 18,
	[18][168] = 18,
	[18][169] = 18,
	[18][170] = 18,
	[18][171] = 18,
	[18][172] = 18,
	[18][173] = 18,
	[18][174] = 18,
	[18][175] = 18,
	[18][176] = 18,
	[18][177] = 18,
	[18][178] = 18,
	[18][179] = 18,
	[18][180] = 18,
	[18][181] = 18,
	[18][182] = 18,
	[18][183] = 18,
	[18][184] = 18,
	[18][185] = 18,
	[18][186] = 18,
	[18][187] = 18,
	[18][188] = 18,
	[18][189] = 18,
	[18][190] = 18,
	[18][191] = 18,
	[18][192] = 18,
	[18][193] = 18,
	[18][194] = 18,
	[18][195] = 18,
	[18][196] = 18,
	[18][197] = 18,
	[18][198] = 18,
	[18][199] = 18,
	[18][200] = 18,
	[18][201] = 18,
	[18][202] = 18,
	[18][203] = 18,
	[18][204] = 18,
	[18][205] = 18,
	[18][206] = 18,
	[18][207] = 18,
	[18][208] = 18,
	[18][209] = 18,
	[18][210] = 18,
	[18][211] = 18,
	[18][212] = 18,
	[18][213] = 18,
	[18][214] = 18,
	[18][215] = 18,
	[18][216] = 18,
	[18][217] = 18,
	[18][218] = 18,
	[18][219] = 18,
	[18][220] = 18,
	[18][221] = 18,
	[18][222] = 18,
	[18][223] = 18,
	[18][224] = 18,
	[18][225] = 18,
	[18][226] = 18,
	[18][227] = 18,
	[18][228] = 18,
	[18][229] = 18,
	[18][230] = 18,
	[18][231] = 18,
	[18][232] = 18,
	[18][233] = 18,
	[18][234] = 18,
	[18][235] = 18,
	[18][236] = 18,
	[18][237] = 18,
	[18][238] = 18,
	[18][239] = 18,
	[18][240] = 18,
	[18][241] = 18,
	[18][242] = 18,
	[18][243] = 18,
	[18][244] = 18,
	[18][245] = 18,
	[18][246] = 18,
	[18][247] = 18,
	[18][248] = 18,
	[18][249] = 18,
	[18][250] = 18,
	[18][251] = 18,
	[18][252] = 18,
	[18][253] = 18,
	[18][254] = 18,
	[18][255] = 18,
	[20][46] = 35,
	[20][48] = 20,
	[20][49] = 20,
	[20][50] = 20,
	[20][51] = 20,
	[20][52] = 20,
	[20][53] = 20,
	[20][54] = 20,
	[20][55] = 20,
	[20][56] = 20,
	[20][57] = 20,
	[21][48] = 21,
	[21][49] = 21,
	[21][50] = 21,
	[21][51] = 21,
	[21][52] = 21,
	[21][53] = 21,
	[21][54] = 21,
	[21][55] = 21,
	[21][56] = 21,
	[21][57] = 21,
	[21][65] = 21,
	[21][66] = 21,
	[21][67] = 21,
	[21][68] = 21,
	[21][69] = 21,
	[21][70] = 21,
	[21][71] = 21,
	[21][72] = 21,
	[21][73] = 21,
	[21][74] = 21,
	[21][75] = 21,
	[21][76] = 21,
	[21][77] = 21,
	[21][78] = 21,
	[21][79] = 21,
	[21][80] = 21,
	[21][81] = 21,
	[21][82] = 21,
	[21][83] = 21,
	[21][84] = 21,
	[21][85] = 21,
	[21][86] = 21,
	[21][87] = 21,
	[21][88] = 21,
	[21][89] = 21,
	[21][90] = 21,
	[21][95] = 21,
	[21][97] = 21,
	[21][98] = 21,
	[21][99] = 21,
	[21][100] = 21,
	[21][101] = 21,
	[21][102] = 21,
	[21][103] = 21,
	[21][104] = 21,
	[21][105] = 21,
	[21][106] = 21,
	[21][107] = 21,
	[21][108] = 21,
	[21][109] = 21,
	[21][110] = 21,
	[21][111] = 21,
	[21][112] = 21,
	[21][113] = 21,
	[21][114] = 21,
	[21][115] = 21,
	[21][116] = 21,
	[21][117] = 21,
	[21][118] = 21,
	[21][119] = 21,
	[21][120] = 21,
	[21][121] = 21,
	[21][122] = 21,
	[22][48] = 21,
	[22][49] = 21,
	[22][50] = 21,
	[22][51] = 21,
	[22][52] = 21,
	[22][53] = 21,
	[22][54] = 21,
	[22][55] = 21,
	[22][56] = 21,
	[22][57] = 21,
	[22][65] = 21,
	[22][66] = 21,
	[22][67] = 21,
	[22][68] = 21,
	[22][69] = 21,
	[22][70] = 21,
	[22][71] = 21,
	[22][72] = 21,
	[22][73] = 21,
	[22][74] = 21,
	[22][75] = 21,
	[22][76] = 21,
	[22][77] = 21,
	[22][78] = 21,
	[22][79] = 21,
	[22][80] = 21,
	[22][81] = 21,
	[22][82] = 21,
	[22][83] = 21,
	[22][84] = 21,
	[22][85] = 21,
	[22][86] = 21,
	[22][87] = 21,
	[22][88] = 21,
	[22][89] = 21,
	[22][90] = 21,
	[22][95] = 21,
	[22][97] = 21,
	[22][98] = 21,
	[22][99] = 21,
	[22][100] = 21,
	[22][101] = 36,
	[22][102] = 21,
	[22][103] = 21,
	[22][104] = 21,
	[22][105] = 21,
	[22][106] = 21,
	[22][107] = 21,
	[22][108] = 21,
	[22][109] = 21,
	[22][110] = 21,
	[22][111] = 21,
	[22][112] = 21,
	[22][113] = 21,
	[22][114] = 21,
	[22][115] = 21,
	[22][116] = 21,
	[22][117] = 21,
	[22][118] = 21,
	[22][119] = 21,
	[22][120] = 21,
	[22][121] = 21,
	[22][122] = 21,
	[23][48] = 21,
	[23][49] = 21,
	[23][50] = 21,
	[23][51] = 21,
	[23][52] = 21,
	[23][53] = 21,
	[23][54] = 21,
	[23][55] = 21,
	[23][56] = 21,
	[23][57] = 21,
	[23][65] = 21,
	[23][66] = 21,
	[23][67] = 21,
	[23][68] = 21,
	[23][69] = 21,
	[23][70] = 21,
	[23][71] = 21,
	[23][72] = 21,
	[23][73] = 21,
	[23][74] = 21,
	[23][75] = 21,
	[23][76] = 21,
	[23][77] = 21,
	[23][78] = 21,
	[23][79] = 21,
	[23][80] = 21,
	[23][81] = 21,
	[23][82] = 21,
	[23][83] = 21,
	[23][84] = 21,
	[23][85] = 21,
	[23][86] = 21,
	[23][87] = 21,
	[23][88] = 21,
	[23][89] = 21,
	[23][90] = 21,
	[23][95] = 21,
	[23][97] = 21,
	[23][98] = 21,
	[23][99] = 21,
	[23][100] = 21,
	[23][101] = 21,
	[23][102] = 21,
	[23][103] = 21,
	[23][104] = 21,
	[23][105] = 21,
	[23][106] = 21,
	[23][107] = 21,
	[23][108] = 37,
	[23][109] = 21,
	[23][110] = 21,
	[23][111] = 21,
	[23][112] = 21,
	[23][113] = 21,
	[23][114] = 21,
	[23][115] = 21,
	[23][116] = 21,
	[23][117] = 21,
	[23][118] = 21,
	[23][119] = 21,
	[23][120] = 21,
	[23][121] = 21,
	[23][122] = 21,
	[25][32] = 38,
	[34][32] = 38,
	[35][48] = 39,
	[35][49] = 39,
	[35][50] = 39,
	[35][51] = 39,
	[35][52] = 39,
	[35][53] = 39,
	[35][54] = 39,
	[35][55] = 39,
	[35][56] = 39,
	[35][57] = 39,
	[36][48] = 21,
	[36][49] = 21,
	[36][50] = 21,
	[36][51] = 21,
	[36][52] = 21,
	[36][53] = 21,
	[36][54] = 21,
	[36][55] = 21,
	[36][56] = 21,
	[36][57] = 21,
	[36][65] = 21,
	[36][66] = 21,
	[36][67] = 21,
	[36][68] = 21,
	[36][69] = 21,
	[36][70] = 21,
	[36][71] = 21,
	[36][72] = 21,
	[36][73] = 21,
	[36][74] = 21,
	[36][75] = 21,
	[36][76] = 21,
	[36][77] = 21,
	[36][78] = 21,
	[36][79] = 21,
	[36][80] = 21,
	[36][81] = 21,
	[36][82] = 21,
	[36][83] = 21,
	[36][84] = 21,
	[36][85] = 21,
	[36][86] = 21,
	[36][87] = 21,
	[36][88] = 21,
	[36][89] = 21,
	[36][90] = 21,
	[36][95] = 21,
	[36][97] = 21,
	[36][98] = 21,
	[36][99] = 21,
	[36][100] = 21,
	[36][101] = 21,
	[36][102] = 21,
	[36][103] = 21,
	[36][104] = 21,
	[36][105] = 40,
	[36][106] = 21,
	[36][107] = 21,
	[36][108] = 21,
	[36][109] = 21,
	[36][110] = 21,
	[36][111] = 21,
	[36][112] = 21,
	[36][113] = 21,
	[36][114] = 21,
	[36][115] = 21,
	[36][116] = 21,
	[36][117] = 21,
	[36][118] = 21,
	[36][119] = 21,
	[36][120] = 21,
	[36][121] = 21,
	[36][122] = 21,
	[37][48] = 21,
	[37][49] = 21,
	[37][50] = 21,
	[37][51] = 21,
	[37][52] = 21,
	[37][53] = 21,
	[37][54] = 21,
	[37][55] = 21,
	[37][56] = 21,
	[37][57] = 21,
	[37][65] = 21,
	[37][66] = 21,
	[37][67] = 21,
	[37][68] = 21,
	[37][69] = 21,
	[37][70] = 21,
	[37][71] = 21,
	[37][72] = 21,
	[37][73] = 21,
	[37][74] = 21,
	[37][75] = 21,
	[37][76] = 21,
	[37][77] = 21,
	[37][78] = 21,
	[37][79] = 21,
	[37][80] = 21,
	[37][81] = 21,
	[37][82] = 21,
	[37][83] = 21,
	[37][84] = 21,
	[37][85] = 21,
	[37][86] = 21,
	[37][87] = 21,
	[37][88] = 21,
	[37][89] = 21,
	[37][90] = 21,
	[37][95] = 21,
	[37][97] = 21,
	[37][98] = 21,
	[37][99] = 21,
	[37][100] = 21,
	[37][101] = 21,
	[37][102] = 21,
	[37][103] = 21,
	[37][104] = 21,
	[37][105] = 21,
	[37][106] = 21,
	[37][107] = 21,
	[37][108] = 21,
	[37][109] = 21,
	[37][110] = 21,
	[37][111] = 41,
	[37][112] = 21,
	[37][113] = 21,
	[37][114] = 21,
	[37][115] = 21,
	[37][116] = 21,
	[37][117] = 21,
	[37][118] = 21,
	[37][119] = 21,
	[37][120] = 21,
	[37][121] = 21,
	[37][122] = 21,
	[39][48] = 42,
	[39][49] = 42,
	[39][50] = 42,
	[39][51] = 42,
	[39][52] = 42,
	[39][53] = 42,
	[39][54] = 42,
	[39][55] = 42,
	[39][56] = 42,
	[39][57] = 42,
	[40][48] = 21,
	[40][49] = 21,
	[40][50] = 21,
	[40][51] = 21,
	[40][52] = 21,
	[40][53] = 21,
	[40][54] = 21,
	[40][55] = 21,
	[40][56] = 21,
	[40][57] = 21,
	[40][65] = 21,
	[40][66] = 21,
	[40][67] = 21,
	[40][68] = 21,
	[40][69] = 21,
	[40][70] = 21,
	[40][71] = 21,
	[40][72] = 21,
	[40][73] = 21,
	[40][74] = 21,
	[40][75] = 21,
	[40][76] = 21,
	[40][77] = 21,
	[40][78] = 21,
	[40][79] = 21,
	[40][80] = 21,
	[40][81] = 21,
	[40][82] = 21,
	[40][83] = 21,
	[40][84] = 21,
	[40][85] = 21,
	[40][86] = 21,
	[40][87] = 21,
	[40][88] = 21,
	[40][89] = 21,
	[40][90] = 21,
	[40][95] = 21,
	[40][97] = 21,
	[40][98] = 21,
	[40][99] = 21,
	[40][100] = 21,
	[40][101] = 21,
	[40][102] = 21,
	[40][103] = 21,
	[40][104] = 21,
	[40][105] = 21,
	[40][106] = 21,
	[40][107] = 21,
	[40][108] = 43,
	[40][109] = 21,
	[40][110] = 21,
	[40][111] = 21,
	[40][112] = 21,
	[40][113] = 21,
	[40][114] = 21,
	[40][115] = 21,
	[40][116] = 21,
	[40][117] = 21,
	[40][118] = 21,
	[40][119] = 21,
	[40][120] = 21,
	[40][121] = 21,
	[40][122] = 21,
	[41][48] = 21,
	[41][49] = 21,
	[41][50] = 21,
	[41][51] = 21,
	[41][52] = 21,
	[41][53] = 21,
	[41][54] = 21,
	[41][55] = 21,
	[41][56] = 21,
	[41][57] = 21,
	[41][65] = 21,
	[41][66] = 21,
	[41][67] = 21,
	[41][68] = 21,
	[41][69] = 21,
	[41][70] = 21,
	[41][71] = 21,
	[41][72] = 21,
	[41][73] = 21,
	[41][74] = 21,
	[41][75] = 21,
	[41][76] = 21,
	[41][77] = 21,
	[41][78] = 21,
	[41][79] = 21,
	[41][80] = 21,
	[41][81] = 21,
	[41][82] = 21,
	[41][83] = 21,
	[41][84] = 21,
	[41][85] = 21,
	[41][86] = 21,
	[41][87] = 21,
	[41][88] = 21,
	[41][89] = 21,
	[41][90] = 21,
	[41][95] = 21,
	[41][97] = 21,
	[41][98] = 21,
	[41][99] = 21,
	[41][100] = 21,
	[41][101] = 21,
	[41][102] = 21,
	[41][103] = 21,
	[41][104] = 21,
	[41][105] = 21,
	[41][106] = 21,
	[41][107] = 21,
	[41][108] = 21,
	[41][109] = 21,
	[41][110] = 21,
	[41][111] = 44,
	[41][112] = 21,
	[41][113] = 21,
	[41][114] = 21,
	[41][115] = 21,
	[41][116] = 21,
	[41][117] = 21,
	[41][118] = 21,
	[41][119] = 21,
	[41][120] = 21,
	[41][121] = 21,
	[41][122] = 21,
	[43][48] = 21,
	[43][49] = 21,
	[43][50] = 21,
	[43][51] = 21,
	[43][52] = 21,
	[43][53] = 21,
	[43][54] = 21,
	[43][55] = 21,
	[43][56] = 21,
	[43][57] = 21,
	[43][65] = 21,
	[43][66] = 21,
	[43][67] = 21,
	[43][68] = 21,
	[43][69] = 21,
	[43][70] = 21,
	[43][71] = 21,
	[43][72] = 21,
	[43][73] = 21,
	[43][74] = 21,
	[43][75] = 21,
	[43][76] = 21,
	[43][77] = 21,
	[43][78] = 21,
	[43][79] = 21,
	[43][80] = 21,
	[43][81] = 21,
	[43][82] = 21,
	[43][83] = 21,
	[43][84] = 21,
	[43][85] = 21,
	[43][86] = 21,
	[43][87] = 21,
	[43][88] = 21,
	[43][89] = 21,
	[43][90] = 21,
	[43][95] = 21,
	[43][97] = 21,
	[43][98] = 21,
	[43][99] = 21,
	[43][100] = 21,
	[43][101] = 21,
	[43][102] = 21,
	[43][103] = 21,
	[43][104] = 21,
	[43][105] = 21,
	[43][106] = 21,
	[43][107] = 21,
	[43][108] = 21,
	[43][109] = 21,
	[43][110] = 21,
	[43][111] = 21,
	[43][112] = 21,
	[43][113] = 21,
	[43][114] = 21,
	[43][115] = 21,
	[43][116] = 21,
	[43][117] = 21,
	[43][118] = 21,
	[43][119] = 21,
	[43][120] = 21,
	[43][121] = 21,
	[43][122] = 21,
	[44][48] = 21,
	[44][49] = 21,
	[44][50] = 21,
	[44][51] = 21,
	[44][52] = 21,
	[44][53] = 21,
	[44][54] = 21,
	[44][55] = 21,
	[44][56] = 21,
	[44][57] = 21,
	[44][65] = 21,
	[44][66] = 21,
	[44][67] = 21,
	[44][68] = 21,
	[44][69] = 21,
	[44][70] = 21,
	[44][71] = 21,
	[44][72] = 21,
	[44][73] = 21,
	[44][74] = 21,
	[44][75] = 21,
	[44][76] = 21,
	[44][77] = 21,
	[44][78] = 21,
	[44][79] = 21,
	[44][80] = 21,
	[44][81] = 21,
	[44][82] = 21,
	[44][83] = 21,
	[44][84] = 21,
	[44][85] = 21,
	[44][86] = 21,
	[44][87] = 21,
	[44][88] = 21,
	[44][89] = 21,
	[44][90] = 21,
	[44][95] = 21,
	[44][97] = 21,
	[44][98] = 21,
	[44][99] = 21,
	[44][100] = 21,
	[44][101] = 21,
	[44][102] = 21,
	[44][103] = 21,
	[44][104] = 21,
	[44][105] = 21,
	[44][106] = 21,
	[44][107] = 21,
	[44][108] = 21,
	[44][109] = 21,
	[44][110] = 21,
	[44][111] = 21,
	[44][112] = 21,
	[44][113] = 21,
	[44][114] = 45,
	[44][115] = 21,
	[44][116] = 21,
	[44][117] = 21,
	[44][118] = 21,
	[44][119] = 21,
	[44][120] = 21,
	[44][121] = 21,
	[44][122] = 21,
	[45][48] = 21,
	[45][49] = 21,
	[45][50] = 21,
	[45][51] = 21,
	[45][52] = 21,
	[45][53] = 21,
	[45][54] = 21,
	[45][55] = 21,
	[45][56] = 21,
	[45][57] = 21,
	[45][65] = 21,
	[45][66] = 21,
	[45][67] = 21,
	[45][68] = 21,
	[45][69] = 21,
	[45][70] = 21,
	[45][71] = 21,
	[45][72] = 21,
	[45][73] = 21,
	[45][74] = 21,
	[45][75] = 21,
	[45][76] = 21,
	[45][77] = 21,
	[45][78] = 21,
	[45][79] = 21,
	[45][80] = 21,
	[45][81] = 21,
	[45][82] = 21,
	[45][83] = 21,
	[45][84] = 21,
	[45][85] = 21,
	[45][86] = 21,
	[45][87] = 21,
	[45][88] = 21,
	[45][89] = 21,
	[45][90] = 21,
	[45][95] = 21,
	[45][97] = 21,
	[45][98] = 21,
	[45][99] = 21,
	[45][100] = 21,
	[45][101] = 21,
	[45][102] = 21,
	[45][103] = 21,
	[45][104] = 21,
	[45][105] = 21,
	[45][106] = 21,
	[45][107] = 21,
	[45][108] = 21,
	[45][109] = 21,
	[45][110] = 21,
	[45][111] = 21,
	[45][112] = 21,
	[45][113] = 21,
	[45][114] = 21,
	[45][115] = 21,
	[45][116] = 21,
	[45][117] = 21,
	[45][118] = 21,
	[45][119] = 21,
	[45][120] = 21,
	[45][121] = 21,
	[45][122] = 21,
};


const unsigned zebu_lexer_starts[147] = {
	[1] = 1,
	[2] = 2,
	[3] = 3,
	[4] = 4,
	[5] = 5,
	[6] = 4,
	[7] = 6,
	[8] = 3,
	[9] = 6,
	[10] = 6,
	[11] = 5,
	[12] = 5,
	[13] = 3,
	[14] = 7,
	[15] = 7,
	[16] = 4,
	[17] = 5,
	[18] = 4,
	[19] = 5,
	[20] = 5,
	[21] = 3,
	[22] = 8,
	[23] = 9,
	[24] = 7,
	[25] = 7,
	[26] = 7,
	[27] = 3,
	[28] = 1,
	[29] = 5,
	[30] = 10,
	[31] = 6,
	[32] = 11,
	[33] = 11,
	[34] = 4,
	[35] = 5,
	[36] = 4,
	[37] = 5,
	[38] = 5,
	[39] = 12,
	[40] = 13,
	[41] = 11,
	[42] = 11,
	[43] = 11,
	[44] = 3,
	[45] = 5,
	[46] = 7,
	[47] = 7,
	[48] = 9,
	[49] = 7,
	[50] = 7,
	[51] = 7,
	[52] = 7,
	[53] = 5,
	[54] = 5,
	[55] = 3,
	[56] = 5,
	[57] = 5,
	[58] = 3,
	[59] = 3,
	[60] = 6,
	[61] = 13,
	[62] = 10,
	[63] = 5,
	[64] = 11,
	[65] = 11,
	[66] = 9,
	[67] = 11,
	[68] = 11,
	[69] = 11,
	[70] = 11,
	[71] = 5,
	[72] = 5,
	[73] = 6,
	[74] = 5,
	[75] = 5,
	[76] = 7,
	[77] = 7,
	[78] = 8,
	[79] = 7,
	[80] = 8,
	[81] = 7,
	[82] = 7,
	[83] = 7,
	[84] = 1,
	[85] = 5,
	[86] = 6,
	[87] = 11,
	[88] = 11,
	[89] = 12,
	[90] = 11,
	[91] = 12,
	[92] = 11,
	[93] = 11,
	[94] = 11,
	[95] = 14,
	[96] = 14,
	[97] = 4,
	[98] = 5,
	[99] = 4,
	[100] = 14,
	[101] = 6,
	[102] = 5,
	[103] = 14,
	[104] = 14,
	[105] = 9,
	[106] = 14,
	[107] = 1,
	[108] = 5,
	[109] = 14,
	[110] = 14,
	[111] = 15,
	[112] = 15,
	[113] = 4,
	[114] = 5,
	[115] = 4,
	[116] = 15,
	[117] = 6,
	[118] = 5,
	[119] = 15,
	[120] = 15,
	[121] = 9,
	[122] = 15,
	[123] = 1,
	[124] = 5,
	[125] = 15,
	[126] = 15,
	[127] = 15,
	[128] = 6,
	[129] = 1,
	[130] = 5,
	[131] = 16,
	[132] = 16,
	[133] = 4,
	[134] = 5,
	[135] = 4,
	[136] = 16,
	[137] = 6,
	[138] = 5,
	[139] = 16,
	[140] = 16,
	[141] = 9,
	[142] = 16,
	[143] = 5,
	[144] = 16,
	[145] = 16,
	[146] = 6,
};


const unsigned zebu_lexer_accepts[46] = {
	[17] = 1,
	[19] = 5,
	[20] = 3,
	[21] = 2,
	[22] = 2,
	[23] = 2,
	[24] = 8,
	[26] = 7,
	[27] = 10,
	[28] = 11,
	[29] = 12,
	[30] = 13,
	[31] = 14,
	[32] = 15,
	[33] = 16,
	[34] = 17,
	[36] = 2,
	[37] = 2,
	[38] = 9,
	[40] = 2,
	[41] = 2,
	[42] = 3,
	[43] = 6,
	[44] = 2,
	[45] = 4,
};


const unsigned zebu_lexer_EOFs[11] = {
	[6] = 29,
	[10] = 29,
};


#ifdef ZEBU_DEBUG
#include <stdbool.h>

struct link
{
	bool is_last;
	struct link* prev;
};

static void print_links(struct link* link)
{
	if (!link) return;
	
	print_links(link->prev);
	
	if (link->is_last)
		fputs("    ", stdout);
	else
		fputs("│   ", stdout);
}

static void print_tree_escape(char *out, char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '/':
		case '`':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02X", in);
			break;
	}
}

enum prefix
{
	p_root,
	p_not_last_child,
	p_last_child,
};

void print_token_leaf(struct link* links, enum prefix p, const char* name, struct zebu_token* token)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m\"", name);
	char escape[10];
	for (unsigned i = 0, n = token->len; i < n; i++)
		print_tree_escape(escape, token->data[i]), fputs(escape, stdout);
	printf("\"\e[0m) on line %u\n", token->line);
}

void print_scanf_leaf(struct link* links, enum prefix p, const char* name, const char* format, ...)
{
	va_list ap;
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[32m%s\e[0m (\e[35m%s\e[m: \e[35m", name, format);
	va_start(ap, format);
	vprintf(format, ap);
	va_end(ap);
	printf("\e[0m)\n");
}

void print_empty_leaf(struct link* links, enum prefix p, const char* type, const char* name)
{
	print_links(links);
	switch (p)
	{
		case p_root: break;
		case p_not_last_child: fputs("├── ", stdout); break;
		case p_last_child: fputs("└── ", stdout); break;
	}
	printf("\e[31m%s\e[0m (\e[36m%s\e[0m)\n", name, type);
}
void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree);

void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree);

void print_zebu_assignment(struct link* links, enum prefix p, const char* name, struct zebu_assignment* ptree);

void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree);

void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree);

void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree);

void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree);

void print_zebu_statement(struct link* links, enum prefix p, const char* name, struct zebu_statement* ptree);

void print_zebu_transaction(struct link* links, enum prefix p, const char* name, struct zebu_transaction* ptree);

void print_zebu_$start(struct link* links, enum prefix p, const char* name, struct zebu_$start* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36m$start\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->statements.n)
	{
		for (unsigned i = 0, n = ptree->statements.n; i < n; i++)
		{
			char label[10 + 30];
			snprintf(label, sizeof(label), "statements[%u]", i);
			print_zebu_statement(new ?: links, i + 1 < n ? p_not_last_child : p_last_child, label, ptree->statements.data[i]);
		}
	}
	else
	{
		print_empty_leaf(new ?: links, p_last_child, "statement[]", "statements");
	}
	free(new);
}
void print_zebu_additive_expression(struct link* links, enum prefix p, const char* name, struct zebu_additive_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36madditive_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "inner");
	if (ptree->left)
		print_zebu_additive_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "additive_expression", "left");
	if (ptree->minus)
		print_token_leaf(new ?: links, p_not_last_child, "minus", ptree->minus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "minus");
	if (ptree->plus)
		print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
	if (ptree->right)
		print_zebu_multiplicative_expression(new ?: links, p_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_last_child, "multiplicative_expression", "right");
	free(new);
}
void print_zebu_assignment(struct link* links, enum prefix p, const char* name, struct zebu_assignment* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36massignment\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->expression)
		print_zebu_expression(new ?: links, p_not_last_child, "expression", ptree->expression);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "expression");
	if (ptree->name)
		print_token_leaf(new ?: links, p_last_child, "name", ptree->name);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "name");
	free(new);
}
void print_zebu_expression(struct link* links, enum prefix p, const char* name, struct zebu_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mexpression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->sub)
		print_zebu_additive_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "additive_expression", "sub");
	free(new);
}
void print_zebu_multiplicative_expression(struct link* links, enum prefix p, const char* name, struct zebu_multiplicative_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mmultiplicative_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->divide)
		print_token_leaf(new ?: links, p_not_last_child, "divide", ptree->divide);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "divide");
	if (ptree->inner)
		print_zebu_prefix_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "prefix_expression", "inner");
	if (ptree->left)
		print_zebu_multiplicative_expression(new ?: links, p_not_last_child, "left", ptree->left);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "multiplicative_expression", "left");
	if (ptree->right)
		print_zebu_prefix_expression(new ?: links, p_not_last_child, "right", ptree->right);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "prefix_expression", "right");
	if (ptree->times)
		print_token_leaf(new ?: links, p_last_child, "times", ptree->times);
	else
		print_empty_leaf(new ?: links, p_last_child, "token", "times");
	free(new);
}
void print_zebu_postfix_expression(struct link* links, enum prefix p, const char* name, struct zebu_postfix_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mpostfix_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->ceil)
		print_token_leaf(new ?: links, p_not_last_child, "ceil", ptree->ceil);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "ceil");
	if (ptree->floor)
		print_token_leaf(new ?: links, p_not_last_child, "floor", ptree->floor);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "floor");
	if (ptree->identifier)
		print_token_leaf(new ?: links, p_not_last_child, "identifier", ptree->identifier);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "identifier");
	if (ptree->literal)
		print_token_leaf(new ?: links, p_not_last_child, "literal", ptree->literal);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "literal");
	if (ptree->subexpression)
		print_zebu_expression(new ?: links, p_last_child, "subexpression", ptree->subexpression);
	else
		print_empty_leaf(new ?: links, p_last_child, "expression", "subexpression");
	free(new);
}
void print_zebu_prefix_expression(struct link* links, enum prefix p, const char* name, struct zebu_prefix_expression* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mprefix_expression\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->inner)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "inner", ptree->inner);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "inner");
	if (ptree->minus)
		print_token_leaf(new ?: links, p_not_last_child, "minus", ptree->minus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "minus");
	if (ptree->plus)
		print_token_leaf(new ?: links, p_not_last_child, "plus", ptree->plus);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "token", "plus");
	if (ptree->sub)
		print_zebu_prefix_expression(new ?: links, p_last_child, "sub", ptree->sub);
	else
		print_empty_leaf(new ?: links, p_last_child, "prefix_expression", "sub");
	free(new);
}
void print_zebu_statement(struct link* links, enum prefix p, const char* name, struct zebu_statement* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mstatement\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->assignment)
		print_zebu_assignment(new ?: links, p_not_last_child, "assignment", ptree->assignment);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "assignment", "assignment");
	if (ptree->transaction)
		print_zebu_transaction(new ?: links, p_last_child, "transaction", ptree->transaction);
	else
		print_empty_leaf(new ?: links, p_last_child, "transaction", "transaction");
	free(new);
}
void print_zebu_transaction(struct link* links, enum prefix p, const char* name, struct zebu_transaction* ptree)
{
	print_links(links);
	
	struct link* new = NULL;
	
	switch (p)
	{
		case p_root:
			break;
		
		case p_not_last_child:
			fputs("├── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = false;
			new->prev = links;
			break;
		
		case p_last_child:
			fputs("└── ", stdout);
			new = malloc(sizeof(*new));
			new->is_last = true;
			new->prev = links;
		break;
	}
	printf("\e[34m%s\e[m (\e[36mtransaction\e[m) on line %u through %u\n", name, ptree->startline, ptree->endline);
	if (ptree->day)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "day", ptree->day);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "day");
	if (ptree->delta)
		print_zebu_expression(new ?: links, p_not_last_child, "delta", ptree->delta);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "expression", "delta");
	if (ptree->hour)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "hour", ptree->hour);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "hour");
	if (ptree->minute)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "minute", ptree->minute);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "minute");
	if (ptree->month)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "month", ptree->month);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "month");
	if (ptree->second)
		print_zebu_postfix_expression(new ?: links, p_not_last_child, "second", ptree->second);
	else
		print_empty_leaf(new ?: links, p_not_last_child, "postfix_expression", "second");
	if (ptree->year)
		print_zebu_postfix_expression(new ?: links, p_last_child, "year", ptree->year);
	else
		print_empty_leaf(new ?: links, p_last_child, "postfix_expression", "year");
	free(new);
}

#endif

struct zebu_token* inc_zebu_token(struct zebu_token* token)
{
	if (token) token->refcount++;
	return token;
}
struct zebu_$start* inc_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_additive_expression* inc_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_assignment* inc_zebu_assignment(struct zebu_assignment* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_expression* inc_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_multiplicative_expression* inc_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_postfix_expression* inc_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_prefix_expression* inc_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_statement* inc_zebu_statement(struct zebu_statement* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}

struct zebu_transaction* inc_zebu_transaction(struct zebu_transaction* ptree)
{
	if (ptree) ptree->refcount++;
	return ptree;
}



extern void free_zebu_token(struct zebu_token* token);
extern void free_zebu_$start(struct zebu_$start* ptree);

extern void free_zebu_additive_expression(struct zebu_additive_expression* ptree);

extern void free_zebu_assignment(struct zebu_assignment* ptree);

extern void free_zebu_expression(struct zebu_expression* ptree);

extern void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree);

extern void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree);

extern void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree);

extern void free_zebu_statement(struct zebu_statement* ptree);

extern void free_zebu_transaction(struct zebu_transaction* ptree);

void free_zebu_token(struct zebu_token* token)
{
	if (token && !--token->refcount)
	{
		free(token->data);
		free(token);
	}
}
void free_zebu_$start(struct zebu_$start* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		for (unsigned i = 0, n = ptree->statements.n; i < n; i++)
			free_zebu_statement(ptree->statements.data[i]);
		free(ptree->statements.data);
		free(ptree);
	}
}

void free_zebu_additive_expression(struct zebu_additive_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_multiplicative_expression(ptree->inner);
		free_zebu_additive_expression(ptree->left);
		free_zebu_token(ptree->minus);
		free_zebu_token(ptree->plus);
		free_zebu_multiplicative_expression(ptree->right);
		free(ptree);
	}
}

void free_zebu_assignment(struct zebu_assignment* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_expression(ptree->expression);
		free_zebu_token(ptree->name);
		free(ptree);
	}
}

void free_zebu_expression(struct zebu_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_additive_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_multiplicative_expression(struct zebu_multiplicative_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->divide);
		free_zebu_prefix_expression(ptree->inner);
		free_zebu_multiplicative_expression(ptree->left);
		free_zebu_prefix_expression(ptree->right);
		free_zebu_token(ptree->times);
		free(ptree);
	}
}

void free_zebu_postfix_expression(struct zebu_postfix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_token(ptree->ceil);
		free_zebu_token(ptree->floor);
		free_zebu_token(ptree->identifier);
		free_zebu_token(ptree->literal);
		free_zebu_expression(ptree->subexpression);
		free(ptree);
	}
}

void free_zebu_prefix_expression(struct zebu_prefix_expression* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_postfix_expression(ptree->inner);
		free_zebu_token(ptree->minus);
		free_zebu_token(ptree->plus);
		free_zebu_prefix_expression(ptree->sub);
		free(ptree);
	}
}

void free_zebu_statement(struct zebu_statement* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_assignment(ptree->assignment);
		free_zebu_transaction(ptree->transaction);
		free(ptree);
	}
}

void free_zebu_transaction(struct zebu_transaction* ptree)
{
	if (ptree && !--ptree->refcount)
	{
		free_zebu_postfix_expression(ptree->day);
		free_zebu_expression(ptree->delta);
		free_zebu_postfix_expression(ptree->hour);
		free_zebu_postfix_expression(ptree->minute);
		free_zebu_postfix_expression(ptree->month);
		free_zebu_postfix_expression(ptree->second);
		free_zebu_postfix_expression(ptree->year);
		free(ptree);
	}
}



#define argv0 (program_invocation_name)

#define N(array) (sizeof(array) / sizeof(*array))

#ifdef ZEBU_DEBUG
static void escape(char *out, unsigned char in)
{
	switch (in)
	{
		case ' ':
		case '~':
		case '!':
		case '@':
		case '#':
		case '$':
		case '%':
		case '^':
		case '&':
		case '*':
		case '-':
		case '+':
		case '=':
		case '|':
		case '/':
		case '<': case '>':
		case '(': case ')':
		case '{': case '}':
		case '[': case ']':
		case ':': case ';':
		case ',': case '.':
		case '_':
		case '0' ... '9':
		case 'a' ... 'z':
		case 'A' ... 'Z':
			*out++ = in;
			*out = 0;
			break;
		
		case '\\': *out++ = '\\', *out++ = '\\', *out = 0; break;
		
		case '\'': *out++ = '\\', *out++ = '\'', *out = 0; break;
		
		case '\"': *out++ = '\\', *out++ = '\"', *out = 0; break;
		
		case '\t': *out++ = '\\', *out++ = 't', *out = 0; break;
		
		case '\n': *out++ = '\\', *out++ = 'n', *out = 0; break;
		
		default:
			sprintf(out, "\\x%02hhX", in);
			break;
	}
}
#endif

struct zebu_$start* zebu_parse(FILE* stream)
{
	void* root;
	struct { unsigned* data, n, cap; } yacc = {};
	struct { void** data; unsigned n, cap; } data = {};
	struct { unsigned char* data; unsigned n, cap; unsigned line; } lexer = {
		.line = 1,
	};
	
	void push_state(unsigned y)
	{
		if (yacc.n + 1 >= yacc.cap)
		{
			yacc.cap = yacc.cap << 1 ?: 1;
			yacc.data = realloc(yacc.data, sizeof(*yacc.data) * yacc.cap);
		}
		yacc.data[yacc.n++] = y;
	}
	
	void push_data(void* d)
	{
		if (data.n + 1 >= data.cap)
		{
			data.cap = data.cap << 1 ?: 1;
			data.data = realloc(data.data, sizeof(*data.data) * data.cap);
		}
		data.data[data.n++] = d;
	}
	
	#ifdef ZEBU_DEBUG
	void ddprintf(const char* fmt, ...)
	{
		for (unsigned i = 0, n = yacc.n; i < n; i++)
			printf("%u ", yacc.data[i]);
		
		printf("| ");
		
		va_list va;
		va_start(va, fmt);
		vprintf(fmt, va);
		va_end(va);
	}
	#endif
	
	void push_char(unsigned char c)
	{
		while (lexer.n + 1 >= lexer.cap)
		{
			lexer.cap = lexer.cap << 1 ?: 1;
			#ifdef ZEBU_DEBUG
			ddprintf("lexer.cap == %u\n", lexer.cap);
			#endif
			lexer.data = realloc(lexer.data, lexer.cap);
		}
		
		lexer.data[lexer.n++] = c;
	}
	
	unsigned y, t, s, r;
	void* td;
	
	void read_token(unsigned l)
	{
		unsigned original_l = l, i = 0, a, b, c, f = 0;
		
		unsigned line = lexer.line;
		
		t = 0;
		
		#ifdef ZEBU_DEBUG
		ddprintf("lexer: \"%.*s\": l = %u\n", lexer.n, lexer.data, l);
		#endif
		
		while (1)
		{
			if (i < lexer.n)
			{
				c = lexer.data[i];
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X) (from cache)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else if ((c = getc(stream)) != EOF)
			{
				push_char(c);
				
				#ifdef ZEBU_DEBUG
				char escaped[10];
				
				escape(escaped, c);
				
				ddprintf("lexer: c = '%s' (0x%X)\n", escaped, c);
				#endif
				
				a = l < N(zebu_lexer) && c < N(*zebu_lexer) ? zebu_lexer[l][c] : 0;
			}
			else
			{
				c = EOF;
				
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: c = <EOF>\n");
				#endif
				
				a = l < N(zebu_lexer_EOFs) ? zebu_lexer_EOFs[l] : 0;
			}
			
			b = l < N(zebu_lexer_accepts) ? zebu_lexer_accepts[l] : 0;
			
			#ifdef ZEBU_DEBUG
			ddprintf("lexer: \"%.*s\" (%u): a = %u, b = %u\n", lexer.n, lexer.data, i, a, b);
			#endif
			
			if (a)
			{
				if (b)
				{
					l = a, t = b, f = i++, lexer.line = line;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				else
				{
					l = a, i++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: l = %u\n", l);
					#endif
				}
				
				if (c == '\n')
				{
					line++;
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: line: %u\n", line);
					#endif
				}
			}
			else if (b)
			{
				#ifdef ZEBU_DEBUG
				ddprintf("lexer: token: \"%.*s\", line: %u\n", i, lexer.data, line);
				#endif
				
				if (!lexer.n)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: EOF.\n");
					#endif
					t = b, td = NULL;
					break;
				}
				else if (b == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: whitespace: \"%.*s\"\n", i, lexer.data);
					#endif
					
					l = original_l, t = 0, lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: i = %u\n", i);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = line;
					token->data = memcpy(malloc(i + 1), lexer.data, i);
					token->data[i] = 0;
					token->len = i;
					t = b, td = token;
					
					lexer.line = line;
					memmove(lexer.data, lexer.data + i, lexer.n - i), lexer.n -= i;
					break;
				}
			}
			else if (t)
			{
				if (t == 1)
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to whitespace: \"%.*s\"\n", f, lexer.data);
					#endif
					
					l = original_l, t = 0, line = lexer.line;
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0, i = 0;
				}
				else
				{
					#ifdef ZEBU_DEBUG
					ddprintf("lexer: falling back to token: \"%.*s\"\n", f, lexer.data);
					#endif
					
					struct zebu_token* token = malloc(sizeof(*token));
					token->refcount = 1;
					token->line = lexer.line;
					token->data = memcpy(malloc(f + 1), lexer.data, f);
					token->data[f] = 0;
					token->len = f;
					td = token;
					
					memmove(lexer.data, lexer.data + f, lexer.n - f), lexer.n -= f, f = 0;
					break;
				}
			}
			else
			{
				if (i != 0)
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' when reading '%.*s' on line %u!\n", argv0, i, lexer.data, line);
					else
						fprintf(stderr, "%s: unexpected '%c' when reading '%.*s' on line %u!\n", argv0, c, i, lexer.data, line);
				}
				else
				{
					if (c == (unsigned) EOF)
						fprintf(stderr, "%s: unexpected '<EOF>' on line %u!\n", argv0, line);
					else
						fprintf(stderr, "%s: unexpected '%c' on line %u!\n", argv0, c, line);
				}
				exit(1);
			}
		}
	}
	
	push_state(1), y = 1, read_token(1);
	
	#ifdef ZEBU_DEBUG
	ddprintf("y = %u, t = %u\n", y, t);
	#endif
	
	while (yacc.n)
	{
		if (y < N(zebu_shifts) && t < N(*zebu_shifts) && (s = zebu_shifts[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("s == %u\n", s);
			#endif
			
			y = s, push_state(y), push_data(td);
			
			read_token(zebu_lexer_starts[y]);
			
			#ifdef ZEBU_DEBUG
			ddprintf("t = %u\n", t);
			#endif
		}
		else if (y < N( zebu_reduces) && t < N(*zebu_reduces) && (r = zebu_reduces[y][t]))
		{
			#ifdef ZEBU_DEBUG
			ddprintf("r == %u\n", r);
			#endif
			
			unsigned g;
			void* d;
			
			switch (r)
{
	case 4:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 13:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_$start* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->statements.n)
{
while (value->statements.n + trie->statements.n > value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + trie->statements.n, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
for (unsigned i = 0, n = trie->statements.n; i < n; i++)
value->statements.data[i] = inc_zebu_statement(trie->statements.data[i]);
value->statements.n += trie->statements.n;
}
free_zebu_$start(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
		d = value, g = 16;
		break;
	}
	case 21:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_$start* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->statements.n)
{
while (value->statements.n + trie->statements.n > value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + trie->statements.n, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
for (unsigned i = 0, n = trie->statements.n; i < n; i++)
value->statements.data[i] = inc_zebu_statement(trie->statements.data[i]);
value->statements.n += trie->statements.n;
}
free_zebu_$start(trie);
}
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 14:
	{
		struct zebu_$start* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_statement* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
if (value->statements.n == value->statements.cap)
{
value->statements.cap = value->statements.cap << 1 ?: 1;
value->statements.data = realloc(value->statements.data, sizeof(*value->statements.data) * value->statements.cap);
}
memmove(value->statements.data + 1, value->statements.data, sizeof(*value->statements.data) * value->statements.n);
value->statements.data[0] = inc_zebu_statement(subgrammar), value->statements.n++;
free_zebu_statement(subgrammar);
}
		d = value, g = 11;
		break;
	}
	case 24:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->right), value->right = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 14;
		break;
	}
	case 27:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->right), value->right = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 15;
		break;
	}
	case 15:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->ceil) { free_zebu_token(value->ceil); value->ceil = inc_zebu_token(trie->ceil); }
if (trie->floor) { free_zebu_token(value->floor); value->floor = inc_zebu_token(trie->floor); }
if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
if (trie->literal) { free_zebu_token(value->literal); value->literal = inc_zebu_token(trie->literal); }
if (trie->subexpression) { free_zebu_expression(value->subexpression); value->subexpression = inc_zebu_expression(trie->subexpression); }
free_zebu_postfix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 5;
		break;
	}
	case 19:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->subexpression), value->subexpression = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
		d = value, g = 6;
		break;
	}
	case 17:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->sub), value->sub = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 12;
		break;
	}
	case 29:
	{
		struct zebu_transaction* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->delta), value->delta = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
		d = value, g = 13;
		break;
	}
	case 23:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->minus) { free_zebu_token(value->minus); value->minus = inc_zebu_token(trie->minus); }
if (trie->plus) { free_zebu_token(value->plus); value->plus = inc_zebu_token(trie->plus); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 7;
		break;
	}
	case 25:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_multiplicative_expression(value->inner); value->inner = inc_zebu_multiplicative_expression(trie->inner); }
if (trie->left) { free_zebu_additive_expression(value->left); value->left = inc_zebu_additive_expression(trie->left); }
if (trie->minus) { free_zebu_token(value->minus); value->minus = inc_zebu_token(trie->minus); }
if (trie->plus) { free_zebu_token(value->plus); value->plus = inc_zebu_token(trie->plus); }
if (trie->right) { free_zebu_multiplicative_expression(value->right); value->right = inc_zebu_multiplicative_expression(trie->right); }
free_zebu_additive_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->minus), value->minus = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->left), value->left = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 7;
		break;
	}
	case 9:
	{
		struct zebu_additive_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->inner), value->inner = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 7;
		break;
	}
	case 22:
	{
		struct zebu_assignment* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_expression(value->expression), value->expression = inc_zebu_expression(subgrammar);
free_zebu_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->name), value->name = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 1;
		break;
	}
	case 8:
	{
		struct zebu_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_additive_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_additive_expression(value->sub), value->sub = inc_zebu_additive_expression(subgrammar);
free_zebu_additive_expression(subgrammar);
}
		d = value, g = 8;
		break;
	}
	case 26:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->divide) { free_zebu_token(value->divide); value->divide = inc_zebu_token(trie->divide); }
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
if (trie->times) { free_zebu_token(value->times); value->times = inc_zebu_token(trie->times); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->times), value->times = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 11:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_prefix_expression(value->inner), value->inner = inc_zebu_prefix_expression(subgrammar);
free_zebu_prefix_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 28:
	{
		struct zebu_multiplicative_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_multiplicative_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->divide) { free_zebu_token(value->divide); value->divide = inc_zebu_token(trie->divide); }
if (trie->inner) { free_zebu_prefix_expression(value->inner); value->inner = inc_zebu_prefix_expression(trie->inner); }
if (trie->left) { free_zebu_multiplicative_expression(value->left); value->left = inc_zebu_multiplicative_expression(trie->left); }
if (trie->right) { free_zebu_prefix_expression(value->right); value->right = inc_zebu_prefix_expression(trie->right); }
if (trie->times) { free_zebu_token(value->times); value->times = inc_zebu_token(trie->times); }
free_zebu_multiplicative_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->divide), value->divide = inc_zebu_token(token);
free_zebu_token(token);
}
{
struct zebu_multiplicative_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_multiplicative_expression(value->left), value->left = inc_zebu_multiplicative_expression(subgrammar);
free_zebu_multiplicative_expression(subgrammar);
}
		d = value, g = 9;
		break;
	}
	case 6:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->ceil) { free_zebu_token(value->ceil); value->ceil = inc_zebu_token(trie->ceil); }
if (trie->floor) { free_zebu_token(value->floor); value->floor = inc_zebu_token(trie->floor); }
if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
if (trie->literal) { free_zebu_token(value->literal); value->literal = inc_zebu_token(trie->literal); }
if (trie->subexpression) { free_zebu_expression(value->subexpression); value->subexpression = inc_zebu_expression(trie->subexpression); }
free_zebu_postfix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->floor), value->floor = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 2;
		break;
	}
	case 1:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->identifier), value->identifier = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 2;
		break;
	}
	case 2:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->literal), value->literal = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 2;
		break;
	}
	case 7:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->ceil) { free_zebu_token(value->ceil); value->ceil = inc_zebu_token(trie->ceil); }
if (trie->floor) { free_zebu_token(value->floor); value->floor = inc_zebu_token(trie->floor); }
if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
if (trie->literal) { free_zebu_token(value->literal); value->literal = inc_zebu_token(trie->literal); }
if (trie->subexpression) { free_zebu_expression(value->subexpression); value->subexpression = inc_zebu_expression(trie->subexpression); }
free_zebu_postfix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
		d = value, g = 2;
		break;
	}
	case 12:
	{
		struct zebu_postfix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_postfix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->ceil) { free_zebu_token(value->ceil); value->ceil = inc_zebu_token(trie->ceil); }
if (trie->floor) { free_zebu_token(value->floor); value->floor = inc_zebu_token(trie->floor); }
if (trie->identifier) { free_zebu_token(value->identifier); value->identifier = inc_zebu_token(trie->identifier); }
if (trie->literal) { free_zebu_token(value->literal); value->literal = inc_zebu_token(trie->literal); }
if (trie->subexpression) { free_zebu_expression(value->subexpression); value->subexpression = inc_zebu_expression(trie->subexpression); }
free_zebu_postfix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->ceil), value->ceil = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 2;
		break;
	}
	case 16:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_postfix_expression(value->inner); value->inner = inc_zebu_postfix_expression(trie->inner); }
if (trie->minus) { free_zebu_token(value->minus); value->minus = inc_zebu_token(trie->minus); }
if (trie->plus) { free_zebu_token(value->plus); value->plus = inc_zebu_token(trie->plus); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->plus), value->plus = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 10;
		break;
	}
	case 18:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_prefix_expression* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->inner) { free_zebu_postfix_expression(value->inner); value->inner = inc_zebu_postfix_expression(trie->inner); }
if (trie->minus) { free_zebu_token(value->minus); value->minus = inc_zebu_token(trie->minus); }
if (trie->plus) { free_zebu_token(value->plus); value->plus = inc_zebu_token(trie->plus); }
if (trie->sub) { free_zebu_prefix_expression(value->sub); value->sub = inc_zebu_prefix_expression(trie->sub); }
free_zebu_prefix_expression(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(value->minus), value->minus = inc_zebu_token(token);
free_zebu_token(token);
}
		d = value, g = 10;
		break;
	}
	case 10:
	{
		struct zebu_prefix_expression* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->inner), value->inner = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
		d = value, g = 10;
		break;
	}
	case 3:
	{
		struct zebu_statement* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_assignment* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_assignment(value->assignment), value->assignment = inc_zebu_assignment(subgrammar);
free_zebu_assignment(subgrammar);
}
		d = value, g = 3;
		break;
	}
	case 5:
	{
		struct zebu_statement* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_transaction* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_transaction(value->transaction), value->transaction = inc_zebu_transaction(subgrammar);
free_zebu_transaction(subgrammar);
}
		d = value, g = 3;
		break;
	}
	case 34:
	{
		struct zebu_transaction* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_transaction* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->day) { free_zebu_postfix_expression(value->day); value->day = inc_zebu_postfix_expression(trie->day); }
if (trie->delta) { free_zebu_expression(value->delta); value->delta = inc_zebu_expression(trie->delta); }
if (trie->hour) { free_zebu_postfix_expression(value->hour); value->hour = inc_zebu_postfix_expression(trie->hour); }
if (trie->minute) { free_zebu_postfix_expression(value->minute); value->minute = inc_zebu_postfix_expression(trie->minute); }
if (trie->month) { free_zebu_postfix_expression(value->month); value->month = inc_zebu_postfix_expression(trie->month); }
if (trie->second) { free_zebu_postfix_expression(value->second); value->second = inc_zebu_postfix_expression(trie->second); }
if (trie->year) { free_zebu_postfix_expression(value->year); value->year = inc_zebu_postfix_expression(trie->year); }
free_zebu_transaction(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->second), value->second = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->minute), value->minute = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->hour), value->hour = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->day), value->day = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->month), value->month = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->year), value->year = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 33:
	{
		struct zebu_transaction* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_transaction* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->day) { free_zebu_postfix_expression(value->day); value->day = inc_zebu_postfix_expression(trie->day); }
if (trie->delta) { free_zebu_expression(value->delta); value->delta = inc_zebu_expression(trie->delta); }
if (trie->hour) { free_zebu_postfix_expression(value->hour); value->hour = inc_zebu_postfix_expression(trie->hour); }
if (trie->minute) { free_zebu_postfix_expression(value->minute); value->minute = inc_zebu_postfix_expression(trie->minute); }
if (trie->month) { free_zebu_postfix_expression(value->month); value->month = inc_zebu_postfix_expression(trie->month); }
if (trie->second) { free_zebu_postfix_expression(value->second); value->second = inc_zebu_postfix_expression(trie->second); }
if (trie->year) { free_zebu_postfix_expression(value->year); value->year = inc_zebu_postfix_expression(trie->year); }
free_zebu_transaction(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->minute), value->minute = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->hour), value->hour = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->day), value->day = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->month), value->month = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->year), value->year = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 32:
	{
		struct zebu_transaction* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_transaction* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->day) { free_zebu_postfix_expression(value->day); value->day = inc_zebu_postfix_expression(trie->day); }
if (trie->delta) { free_zebu_expression(value->delta); value->delta = inc_zebu_expression(trie->delta); }
if (trie->hour) { free_zebu_postfix_expression(value->hour); value->hour = inc_zebu_postfix_expression(trie->hour); }
if (trie->minute) { free_zebu_postfix_expression(value->minute); value->minute = inc_zebu_postfix_expression(trie->minute); }
if (trie->month) { free_zebu_postfix_expression(value->month); value->month = inc_zebu_postfix_expression(trie->month); }
if (trie->second) { free_zebu_postfix_expression(value->second); value->second = inc_zebu_postfix_expression(trie->second); }
if (trie->year) { free_zebu_postfix_expression(value->year); value->year = inc_zebu_postfix_expression(trie->year); }
free_zebu_transaction(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->hour), value->hour = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->day), value->day = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->month), value->month = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->year), value->year = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 31:
	{
		struct zebu_transaction* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_transaction* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->day) { free_zebu_postfix_expression(value->day); value->day = inc_zebu_postfix_expression(trie->day); }
if (trie->delta) { free_zebu_expression(value->delta); value->delta = inc_zebu_expression(trie->delta); }
if (trie->hour) { free_zebu_postfix_expression(value->hour); value->hour = inc_zebu_postfix_expression(trie->hour); }
if (trie->minute) { free_zebu_postfix_expression(value->minute); value->minute = inc_zebu_postfix_expression(trie->minute); }
if (trie->month) { free_zebu_postfix_expression(value->month); value->month = inc_zebu_postfix_expression(trie->month); }
if (trie->second) { free_zebu_postfix_expression(value->second); value->second = inc_zebu_postfix_expression(trie->second); }
if (trie->year) { free_zebu_postfix_expression(value->year); value->year = inc_zebu_postfix_expression(trie->year); }
free_zebu_transaction(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->day), value->day = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->month), value->month = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->year), value->year = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 30:
	{
		struct zebu_transaction* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_transaction* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->day) { free_zebu_postfix_expression(value->day); value->day = inc_zebu_postfix_expression(trie->day); }
if (trie->delta) { free_zebu_expression(value->delta); value->delta = inc_zebu_expression(trie->delta); }
if (trie->hour) { free_zebu_postfix_expression(value->hour); value->hour = inc_zebu_postfix_expression(trie->hour); }
if (trie->minute) { free_zebu_postfix_expression(value->minute); value->minute = inc_zebu_postfix_expression(trie->minute); }
if (trie->month) { free_zebu_postfix_expression(value->month); value->month = inc_zebu_postfix_expression(trie->month); }
if (trie->second) { free_zebu_postfix_expression(value->second); value->second = inc_zebu_postfix_expression(trie->second); }
if (trie->year) { free_zebu_postfix_expression(value->year); value->year = inc_zebu_postfix_expression(trie->year); }
free_zebu_transaction(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->month), value->month = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->year), value->year = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
	case 20:
	{
		struct zebu_transaction* value = memset(malloc(sizeof(*value)), 0, sizeof(*value));
		value->startline = -1;
		value->endline = 0;
		value->refcount = 1;
{
struct zebu_transaction* trie = data.data[--yacc.n, --data.n];
if (trie->startline < value->startline) value->startline = trie->startline;
if (value->endline < trie->endline) value->endline = trie->endline;
if (trie->day) { free_zebu_postfix_expression(value->day); value->day = inc_zebu_postfix_expression(trie->day); }
if (trie->delta) { free_zebu_expression(value->delta); value->delta = inc_zebu_expression(trie->delta); }
if (trie->hour) { free_zebu_postfix_expression(value->hour); value->hour = inc_zebu_postfix_expression(trie->hour); }
if (trie->minute) { free_zebu_postfix_expression(value->minute); value->minute = inc_zebu_postfix_expression(trie->minute); }
if (trie->month) { free_zebu_postfix_expression(value->month); value->month = inc_zebu_postfix_expression(trie->month); }
if (trie->second) { free_zebu_postfix_expression(value->second); value->second = inc_zebu_postfix_expression(trie->second); }
if (trie->year) { free_zebu_postfix_expression(value->year); value->year = inc_zebu_postfix_expression(trie->year); }
free_zebu_transaction(trie);
}
{
struct zebu_token* token = data.data[--yacc.n, --data.n];
if (token->line < value->startline) value->startline = token->line;
if (value->endline < token->line) value->endline = token->line;
free_zebu_token(token);
}
{
struct zebu_postfix_expression* subgrammar = data.data[--yacc.n, --data.n];
if (subgrammar->startline < value->startline) value->startline = subgrammar->startline;
if (value->endline < subgrammar->endline) value->endline = subgrammar->endline;
free_zebu_postfix_expression(value->year), value->year = inc_zebu_postfix_expression(subgrammar);
free_zebu_postfix_expression(subgrammar);
}
		d = value, g = 4;
		break;
	}
}
			
			if (g == 16)
			{
				free_zebu_token(td);
				yacc.n = 0, root = d;
			}
			else
			{
				y = yacc.data[yacc.n - 1];
				
				#ifdef ZEBU_DEBUG
				ddprintf("y = %u\n", y);
				#endif
				
				assert(y < N(zebu_gotos) && g < N(*zebu_gotos));
				
				s = zebu_gotos[y][g];
				
				#ifdef ZEBU_DEBUG
				ddprintf("s = %u\n", s);
				#endif
				
				y = s, push_state(y), push_data(d);
			}
		}
		else
		{
			struct zebu_token* token = td;
			
			fprintf(stderr, "zebu: unexpected token '%.*s'!\n", token->len, token->data);
			
			exit(1);
		}
	}
	
	#ifdef ZEBU_DEBUG
	print_zebu_$start(NULL, p_root, "start", root);
	#endif
	
	free(yacc.data);
	free(data.data);
	free(lexer.data);
	
	return root;
}

















